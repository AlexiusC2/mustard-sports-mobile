# mustard_sports

# TI7
1. Widget tree adalah struktur hierarki dari seluruh widget yang membentuk tampilan aplikasi Flutter. Setiap elemen dalam aplikasi, seperti teks, tombol, atau layout, merupakan bagian dari pohon widget ini. Widget diatur dalam hubungan parent–child, di mana widget induk (parent) membungkus widget anak (child) dan menentukan bagaimana anak tersebut ditampilkan atau diatur. Misalnya, widget Column dapat menjadi parent yang berisi beberapa Text atau ElevatedButton sebagai child-nya. Melalui struktur ini, Flutter dapat dengan efisien mengelola dan memperbarui tampilan ketika terjadi perubahan data atau state.
2. Dalam proyek ini, saya menggunakan beberapa widget: MaterialApp (root widget untuk konfigurasi tema dan navigasi), Scaffold (struktur dasar halaman), AppBar (bar judul di atas), Text (menampilkan teks), Padding (memberikan jarak), Column (menyusun widget vertikal), Row (menyusun widget horizontal), Card (kotak dengan bayangan), Container (mengatur ukuran dan dekorasi), Center (menempatkan widget di tengah), GridView.count (menampilkan grid), Material (efek visual Material Design), InkWell (deteksi tap dengan efek ripple), Icon (menampilkan ikon), SizedBox (memberikan jarak kosong), ScaffoldMessenger (mengelola SnackBar), dan SnackBar (notifikasi sementara).
3. MaterialApp berfungsi sebagai titik awal (root widget) dalam aplikasi Flutter yang menggunakan desain Material Design. Widget ini menyediakan pengaturan global seperti tema (warna, font, gaya), sistem navigasi antar halaman (routes), serta manajemen lokal dan bahasa. Karena MaterialApp secara otomatis mengonfigurasi elemen-elemen dasar seperti Scaffold, AppBar, dan Theme, widget ini hampir selalu digunakan sebagai root untuk memastikan konsistensi tampilan dan pengalaman pengguna yang sesuai standar Material Design.
4. StatelessWidget adalah widget yang tidak memiliki perubahan keadaan (state) selama aplikasi berjalan. Artinya, tampilannya hanya bergantung pada data awal dan tidak akan berubah kecuali dilakukan rebuild dari luar. Sebaliknya, StatefulWidget memiliki state yang dapat berubah seiring waktu, misalnya ketika pengguna menekan tombol atau data dari API diperbarui. StatelessWidget digunakan untuk komponen statis seperti teks, ikon, atau label, sedangkan StatefulWidget dipilih untuk elemen interaktif seperti form, counter, atau tampilan yang berubah dinamis.
5. BuildContext adalah objek yang merepresentasikan lokasi sebuah widget dalam widget tree. Konteks ini penting karena memungkinkan widget untuk mengakses informasi dari parent-nya, seperti tema, navigator, atau ukuran layar. Dalam metode build, BuildContext digunakan untuk membangun widget baru dengan referensi posisi dan informasi lingkungan tempat widget tersebut berada. Misalnya, Theme.of(context) atau Navigator.of(context) menggunakan konteks untuk mengambil data dari widget di atasnya.
6. Hot reload adalah fitur Flutter yang memungkinkan pengembang melihat perubahan kode secara langsung tanpa kehilangan state aplikasi yang sedang berjalan. Dengan hot reload, perubahan tampilan atau logika sederhana dapat diterapkan seketika, sehingga proses pengembangan menjadi lebih cepat dan interaktif. Sementara itu, hot restart akan memuat ulang seluruh aplikasi dari awal dan menginisialisasi ulang semua state. Hot restart digunakan ketika ada perubahan mendasar, seperti pada struktur widget utama atau variabel global yang tidak bisa diperbarui hanya dengan hot reload.

# TI 8
1. Perbedaan utama antara Navigator.push() dan Navigator.pushReplacement() terletak pada cara keduanya mengelola tumpukan (stack) navigasi. Navigator.push() menambahkan halaman baru di atas halaman saat ini, sehingga halaman lama tetap ada di tumpukan dan pengguna dapat kembali menggunakan tombol "back". Ini ideal digunakan pada aplikasi Mustard Sports saat menekan tombol "Create Product" atau memilih "Tambah Produk" dari drawer, karena pengguna perlu kembali ke halaman utama setelah selesai. Sebaliknya, Navigator.pushReplacement() mengganti halaman saat ini dengan halaman baru dan menghapus halaman lama dari tumpukan, sehingga pengguna tidak bisa kembali. Metode ini sebaiknya digunakan saat memilih "Halaman Utama" dari drawer untuk menghindari penumpukan halaman utama yang tidak perlu.
2. Struktur halaman yang konsisten di seluruh aplikasi dibangun dengan memanfaatkan hirarki widget inti Flutter. Scaffold bertindak sebagai kerangka dasar untuk setiap halaman, menyediakan properti standar untuk elemen umum. AppBar, yang ditempatkan di properti appBar milik Scaffold, memastikan setiap halaman memiliki title bar yang seragam di bagian atas. Terakhir, Drawer digunakan untuk navigasi yang konsisten. Dengan membuat satu widget LeftDrawer kustom dan memanggilnya di properti drawer pada setiap Scaffold (seperti di lib/menu.dart dan lib/product_form.dart), menu navigasi yang sama persis akan muncul di seluruh aplikasi, memastikan pengalaman pengguna yang koheren.
3. Widget layout ini sangat penting untuk fungsionalitas form. Column digunakan untuk menyusun elemen-elemen form (seperti TextFormField) secara vertikal. Padding memberikan "ruang napas" visual di sekitar setiap elemen. Terakhir, SingleChildScrollView membungkus seluruh form agar halaman tetap bisa di-scroll saat keyboard virtual muncul, sehingga menghindari pixel overflow error.
4. Identitas visual dan warna brand aplikasi diatur secara terpusat di dalam ThemeData pada widget MaterialApp di lib/main.dart. Dengan mendefinisikan colorScheme (misalnya primarySwatch: Colors.blue), widget lain seperti AppBar dapat secara otomatis menggunakan warna utama ini (Theme.of(context).colorScheme.primary), sehingga menjamin tampilan yang konsisten di seluruh aplikasi.

# TI 9
1. Ketika mengambil atau mengirim data JSON, kita membuat model Dart agar data yang diterima memiliki struktur yang jelas, tipe data yang terjamin, dan aman dari error null-safety. Jika kita hanya memakai Map<String, dynamic> tanpa model, maka tidak ada validasi tipe—misalnya nilai yang seharusnya int bisa saja terbaca sebagai String tanpa kita sadari. Selain itu, akses data menjadi lebih rawan error karena kesalahan penulisan key tidak terdeteksi oleh compiler. Tanpa model, kode juga menjadi sulit dirawat (maintainability rendah), terutama ketika JSON bertambah kompleks atau API berubah karena setiap akses field harus ditangani secara manual.
2. Package http digunakan untuk melakukan request HTTP biasa seperti GET/POST tanpa penyimpanan session atau cookie. Ia cocok untuk endpoint yang tidak membutuhkan autentikasi. Sementara itu, CookieRequest (dari package pbp_django_auth) dirancang khusus untuk integrasi dengan Django yang memakai session authentication. CookieRequest otomatis menyimpan cookie session yang diberikan Django, sehingga bisa dipakai untuk melakukan request ke endpoint yang membutuhkan login. Jadi, http menangani request stateless biasa, sedangkan CookieRequest menangani request yang harus mempertahankan sesi login.
3. Karena autentikasi berbasis session Django membutuhkan cookie yang konsisten, seluruh bagian aplikasi Flutter harus memakai instance CookieRequest yang sama. Jika setiap halaman membuat instance baru, cookie session tidak akan terbawa dan pengguna dianggap tidak login di halaman lain. Dengan membagikan satu instance melalui Provider atau mekanisme global lain, seluruh request akan menggunakan cookie yang sama sehingga status login tetap konsisten di seluruh aplikasi.
4. Agar Flutter dapat berkomunikasi dengan Django di Android emulator, kita perlu menambahkan 10.0.2.2 ke ALLOWED_HOSTS karena alamat tersebut adalah cara emulator mengakses komputer host. Selain itu, Django harus mengaktifkan CORS agar Flutter (yang berjalan di lingkungan berbeda) diizinkan melakukan request lintas domain. Pengaturan SameSite dan cookie juga penting agar cookie session dapat dikirim balik ke Flutter selama proses login. Di sisi Android, izin akses internet harus ditambahkan dalam AndroidManifest.xml. Jika salah satu konfigurasi ini tidak dilakukan, aplikasi bisa gagal login, request diblokir oleh CORS, cookie tidak terkirim, atau bahkan Flutter tidak bisa mengakses server sama sekali.
5. Data dikirim mulai dari input pengguna pada form Flutter. Setelah tombol submit ditekan, data tersebut dikemas dalam body POST dan dikirim ke Django melalui http atau CookieRequest. Django menerima data, memprosesnya (misalnya menyimpan ke database), lalu mengirimkan response dalam format JSON. Flutter menerima JSON tersebut, memetakannya ke model Dart, lalu menampilkan data yang sudah terstruktur tersebut pada UI.
6. Ketika pengguna memasukkan data akun pada Flutter, data tersebut dikirim melalui CookieRequest ke endpoint Django (login, register). Django memverifikasi data, dan jika valid, Django membuat session dan mengembalikan cookie session tersebut. CookieRequest menyimpan cookie itu otomatis sehingga pada request berikutnya, Django mengenali pengguna sebagai user yang sudah login. Saat login berhasil, Flutter bisa menampilkan menu khusus pengguna. Mekanisme yang sama berlaku untuk register (menambah user baru), sedangkan logout akan menghapus session di Django dan menghapus cookie di CookieRequest, membuat pengguna kembali ke kondisi tidak login.
7. Implementasi Checklist Step-by-Step
   a. Persiapan Model dan Backend
   Langkah pertama adalah memastikan model Product di main/models.py sudah lengkap dengan semua field yang dibutuhkan. Setelah itu, saya menggunakan tool konverter (Quicktype) untuk membuat model Dart yang identik di lib/models/product_entry.dart. Ini penting agar Flutter bisa mem-parsing JSON dengan tipe data yang benar dan null-safe.
   
   Sebelum membuat UI Flutter, saya terlebih dahulu menguji endpoint backend. Saya menyesuaikan view show_json di main/views.py untuk memastikan data JSON dapat diakses dengan benar. Saya membuka endpoint /json/ di browser untuk memverifikasi bahwa respons JSON muncul dengan struktur yang sesuai.
   
   b. Integrasi Fetch dan Display Data
   Dengan API yang sudah berfungsi, saya mulai membuat UI Flutter. Saya membuat file lib/screens/product_entry_list.dart yang bertugas memanggil endpoint /json/ menggunakan CookieRequest.get(). Data JSON yang diterima diubah menjadi list objek ProductEntry melalui method fromJson. Untuk menampilkan setiap produk, saya membuat widget ProductEntryCard di lib/widgets/product_entry_card.dart yang menampilkan informasi produk dalam bentuk card.
   
   c. Implementasi Autentikasi
   Agar aplikasi aman, saya membangun sistem autentikasi lengkap. Di sisi Django, saya membuat app authentication dengan tiga view: login, register, dan logout yang menerima request JSON dan mengembalikan response JSON. 
   
   Di sisi Flutter, saya membuat lib/screens/login.dart dan lib/screens/register.dart. Yang krusial adalah mengonfigurasi lib/main.dart untuk menggunakan Provider yang membungkus CookieRequest, sehingga instance cookie dapat dibagikan ke seluruh aplikasi. Untuk register, saya menggunakan request.postJson() agar body dikirim sebagai JSON. Untuk login, saya menggunakan request.login() yang secara otomatis menyimpan cookie sesi yang dikembalikan Django.
   
   Saya juga menambahkan tombol "Logout" di header AppBar yang memanggil fungsi handleLogout() di lib/widgets/product_card.dart, kemudian mengaturnya di lib/screens/menu.dart agar tombol muncul di pojok kanan atas.
   
   d. Fitur Create Product
   Setelah login berfungsi, saya menambahkan fitur untuk menambah produk baru. Di Django, saya membuat view create_product_flutter di main/views.py, melindunginya dengan decorator @csrf_exempt dan @login_required, lalu mendaftarkannya ke path /create-flutter/.
   
   Di Flutter, saya membuat form lengkap di lib/screens/productform.dart dengan validasi untuk name, price, description, category, thumbnail, dan is_featured. Saat tombol "Save" ditekan, data dikirim menggunakan request.postJson() dengan body JSON. Karena CookieRequest sudah menyimpan cookie login, request ini otomatis membawa autentikasi dan berhasil melewati @login_required.
   
   e. Detail Product dan Filter My Products
   Saya membuat halaman detail di lib/screens/product_detail.dart yang menampilkan semua atribut produk, termasuk userId dan username penjual. Namun, saat testing saya menemukan bug: field "Penjual" menampilkan "Tidak diketahui". Setelah investigasi, ternyata show_json di main/views.py tidak mengirim field user_username. Saya memperbaikinya dengan menambahkan field tersebut di serializer JSON.
   
   Dengan akses ke request.user di view Django, saya menyadari bisa menambahkan filter "My Products" dengan mudah. Saya menambahkan logika if request.GET.get('filter') == 'all' di view untuk membedakan antara menampilkan semua produk atau hanya produk user yang login. Di Flutter, saya memperbarui ProductEntryListPage agar menerima parameter initialFilter dan mengubah URL request sesuai filter yang dipilih.
   
   f. Penyesuaian Desain dengan Web Django
   Saya menyesuaikan desain Flutter agar konsisten dengan web Django yang sudah ada sebelumnya. Saya menggunakan skema warna Mustard Sports (kuning emas #E6B800) di ColorScheme, AppBar, ElevatedButton, dan widget lainnya. Saya juga menata ulang menu utama dengan tiga tombol (All Products, My Products, Create Product) di tengah dan tombol Logout di pojok kanan atas AppBar.
   
   g. Testing dan Deployment
   Untuk testing lokal, saya menggunakan URL http://localhost:8000 di semua endpoint agar bisa menjalankan Flutter di Chrome dan menguji fitur-fitur dengan Django development server. Setelah semua fitur berfungsi dengan baik, saya mengubah semua URL ke link PWS (https://alexius-christhoper-mustardsports.pbp.cs.ui.ac.id) sebelum commit dan push ke repository, sehingga aplikasi dapat diakses secara online. 